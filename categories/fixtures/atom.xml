<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: fixtures | geeknam's blog]]></title>
  <link href="http://geeknam.github.com/categories/fixtures/atom.xml" rel="self"/>
  <link href="http://geeknam.github.com/"/>
  <updated>2012-02-14T11:54:53+11:00</updated>
  <id>http://geeknam.github.com/</id>
  <author>
    <name><![CDATA[Ngo Minh Nam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Loading fixtures in Django tests]]></title>
    <link href="http://geeknam.github.com/2012/02/13/loading-fixtures-in-django-tests/"/>
    <updated>2012-02-13T14:22:00+11:00</updated>
    <id>http://geeknam.github.com/2012/02/13/loading-fixtures-in-django-tests</id>
    <content type="html"><![CDATA[<p>When writing tests in Django apps, I have an urge to reuse code in setUp() across all tests (most of my apps use the same setUp). So I come up with a GlobalSetup class that other tests should inherit from (it's located at the project level). However, this approach creates a problem with loading fixtures. According to Django <a href="https://docs.djangoproject.com/en/dev/topics/testing/">docs</a>: <!-- more --></p>

<p><blockquote><p>Once you've created a fixture and placed it in a fixtures directory in one of your INSTALLED_APPS, you can use it in your unit tests by specifying a fixtures class attribute on your django.test.TestCase subclass</p></blockquote></p>

<p>And you would normally do this to load the fixtures:<br/>
``` python
from django.test import TestCase</p>

<p>class PoniesTest(TestCase):</p>

<pre><code>fixtures = ['ponies']

def test_ponies(self):
    call_some_test_code()
</code></pre>

<p><code>
How should we load the fixtures now, when the test file is not at the apps level?
Instead of creating fixures folder and placing fixtures in them (in every app), a better and neater way to handle this would be to put all fixtures in one folder at the project level and load them. You can do this with `call_command` as following:  
</code> python
from django.test import TestCase
from django.core.management import call_command</p>

<p>class GlobalSetup(self):</p>

<pre><code># Create some ponies and snakes here
def setUp(self):
    # Load fixtures
    call_command('loaddata', 'tests/ponies', verbosity=0)
</code></pre>

<p>```</p>

<p>Invoking this <code>call_command</code> is equivalent to running <code>manage.py loaddata /path/to/fixtures</code>
The test in each app can now inherit GlocalSetup and reuse setUp():
``` python
from project.tests import GlobalSetup</p>

<p>class PoniesTest(GlobalSetup):</p>

<pre><code>def setUp(self):
    super(PoniesTest, self).setUp()

def test_ponies(self):
    call_some_test_code()
</code></pre>

<p><code>``
You could also limit each test to load different fixtures by passing a list of fixtures name</code>['ponies', 'snakes']` to setUp().
Hope this will help you to DRY up your tests.</p>
]]></content>
  </entry>
  
</feed>
