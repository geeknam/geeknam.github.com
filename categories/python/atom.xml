<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | geeknam's blog]]></title>
  <link href="http://blog.namis.me/categories/python/atom.xml" rel="self"/>
  <link href="http://blog.namis.me/"/>
  <updated>2012-05-13T04:47:35+10:00</updated>
  <id>http://blog.namis.me/</id>
  <author>
    <name><![CDATA[Ngo Minh Nam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Writing unit tests for Django middleware]]></title>
    <link href="http://blog.namis.me/2012/05/13/writing-unit-tests-for-django-middleware/"/>
    <updated>2012-05-13T02:21:00+10:00</updated>
    <id>http://blog.namis.me/2012/05/13/writing-unit-tests-for-django-middleware</id>
    <content type="html"><![CDATA[<p>Sometimes, it is a pain in the ass to write tests for Django apps (even though Django provides some pretty awesome testing tools out of box). One of the scenarios is testing middleware. Let's take a look at this middleware.</p>

<p>``` python
from .cart import Cart</p>

<p>class CartMiddleware:</p>

<pre><code>def process_request(self, request):
    '''Load the current cart from the session, or create a new one'''
    cart = request.session.get('cart', None)

    if cart is None:
        cart = Cart()
    else:
        cart = Cart(**cart)

    setattr(request, 'cart', cart)
    return None
</code></pre>

<p>```</p>

<!-- more -->


<p><strong>What the middleware does:</strong><br/>
- It gets attributes/values of the cart from the session<br/>
- It creates a cart with those unpacked arguments or creates a fresh cart and attaches this cart to the request object.</p>

<p><strong>Now, let's analyze what needs to be tested:</strong><br/>
1. Assert that if the cart exists in the session, it should be set as an attribute of the request<br/>
2. Assert that if the cart doesn't exist in the session, a new cart is created and attached to the request object<br/>
3. Assert that all attributes of the cart can be accessed after the cart is attached to the request object</p>

<p><strong>How about dependencies? What do we need in order to write this test?</strong><br/>
- CartMiddleware class (this can be easily imported)<br/>
- <code>request</code> object as an argument in process_request(). This one is hard to obtain, and since we are writing a unit test, let's just mock it.</p>

<p>We are now ready to write the test</p>

<p>``` python
from django.test import TestCase
from mock import Mock
from .cart import CartMiddleware, Cart</p>

<p>class CartMiddlewareTest(TestCase):</p>

<pre><code>def setUp(self):
    self.cm = CartMiddleware()
    self.request = Mock()
    self.request.session = {}
</code></pre>

<p>```</p>

<p>This sets up an instance of CartMiddleware and mocks a request. I'm using Michael Foord's <code>mock</code> library to assist me with this. Since we know <code>session</code> is a dictionary like object, we can mock it with an empty dictionary for now.</p>

<p>``` python</p>

<pre><code>def test_process_request_without_cart(self):
    self.assertEqual(self.cm.process_request(self.request), None)
    self.assertIsInstance(self.request.cart, Cart)

def test_process_request_with_cart(self):
    data = {'postcode': '3050'}
    self.request.session = {'cart': data}
    self.assertEqual(self.cm.process_request(self.request), None)
    self.assertIsInstance(self.request.cart, Cart)
    self.assertEqual(self.request.cart.postcode, data['postcode'])
</code></pre>

<p>```</p>

<p><strong>The first test asserts that (without a cart in the session):</strong><br/>
- process_request returns None<br/>
- Cart object has been attached to request as an attribute</p>

<p><strong>The second test asserts that (with a cart in the session):</strong><br/>
- process_request returns None<br/>
- Dictionary containing cart attributes in <code>session</code> is unpacked and used to create a Cart object.<br/>
- The cart attribute (postcode in this case) can be accessed</p>

<p><strong>Conclusion</strong><br/>
As you could see, I didn't have to use <code>django.test.client.Client</code> to create requests, responses or sessions. When writing unit tests, one shouldn't care much about creating a precise dependency because, eventually what needs to be tested is the behaviour of the code and not the dependency itself. Therefore, it is more advisable to mock those dependencies in order to satisfy the conditions of the unit of code we test.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Burn your fixtures, use model factories]]></title>
    <link href="http://blog.namis.me/2012/04/21/burn-your-fixtures/"/>
    <updated>2012-04-21T16:46:00+10:00</updated>
    <id>http://blog.namis.me/2012/04/21/burn-your-fixtures</id>
    <content type="html"><![CDATA[<p>This blog post is inspired by one of the talks in PyCon US 2012 by <a href="http://twitter.com/carljm">Carl Meyer</a> named <a href="http://pyvideo.org/video/699/testing-and-django">Testing and Django</a> in which he discusssed the guidelines for writing good tests.</p>

<p>After watching the whole talk, I realised what I've been doing is all wrong. The fact that tests I write run within minutes shows how terrible my unit-test-fu is. Using fixtures was a really bad idea. Each test case I wrote would load some fixtures to setup necessary dependencies. Sometimes, this creates a problem when the model has been redesigned. The fixtures would have to be edited due to the change of the model otherwise they won't be installed properly.</p>

<p>Instead of using fixtures, Carl introduced <code>model factories</code> which would create a model instance with default values. Of course, you will have a flexibility to change those default values to suit each of your test because naturally, when you test a behaviour of a class, you definitely need it to be in different conditions.</p>

<!-- more -->


<p>Here is an example of a model factory that was used in the talk:</p>

<p>``` python
def create_profile(**kwargs):</p>

<pre><code>defaults = {
    "likes_cheese": True,
    "age": 32,
    "address": "3815 Brookside Dr",
}
defaults.update(kwargs)
if "user" not in defaults:
    defaults["user"] = create_user()
return Profile.objects.create(**defaults)
</code></pre>

<p>```</p>

<p>And this is how you could use it in the test:</p>

<p>``` python
def test_can_vote(self):</p>

<pre><code>"""A user age 18+ can vote in the US."""
profile = create_profile(age=18)
self.assertTrue(profile.can_vote)
</code></pre>

<p>```</p>

<p>This approach solves the problem with maintaining the fixtures to suit your model design. If your model changes, the only thing you have to edit is the default values of the factory. Therefore <code>model factories</code> are way easier to maintain. If you need a large data set, you could easily write a for loop that wraps the model factory. So burn all your fixture right now !!!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django custom email form field for Email Pie]]></title>
    <link href="http://blog.namis.me/2012/03/27/django-custom-email-form-field-for-email-pie/"/>
    <updated>2012-03-27T01:14:00+11:00</updated>
    <id>http://blog.namis.me/2012/03/27/django-custom-email-form-field-for-email-pie</id>
    <content type="html"><![CDATA[<p><span class='pullquote-right' data-pullquote='Email Pie is a wonderful little JSON API that gives you a simple way to validate email addresses. We&#8217;ll let you know if that email address is legit or not.'>
As you know Django's <code>forms.EmailField()</code> is capable of validating email addresses but what if you wanted to validate the existence of a particular email address? I've found a pretty neat solution for that, it's called <a href="http://emailpie.com/">Email Pie</a>.
Email Pie is a wonderful little JSON API that gives you a simple way to validate email addresses. We'll let you know if that email address is legit or not.. You could either use the service hosted on emailpie.com or run your own instance (it's open source). In this post, I'm going to show you how to write a custom form field that makes use of Email Pie.</p>

<!-- more -->


<p>Make sure you pip install <code>requests</code> and <code>simplejson</code> before proceeding. Now create a <code>fields.py</code> file with the following content:</p>

<p>``` python fields.py
import requests
import simplejson</p>

<p>from django import forms
from django.core.exceptions import ValidationError</p>

<p>EMAIL_PIE_HOST = 'http://emailpie.com'  # change this if you run your own instance</p>

<p>def validate_email_pie(value):</p>

<pre><code>params = {'email': value}
response = requests.get('%s/v1/check' % EMAIL_PIE_HOST, params=params)
response = simplejson.loads(response.content)

if not response['success']:
    raise ValidationError(response['errors'][0]['message'])
</code></pre>

<p>class EmailPieField(forms.EmailField):</p>

<pre><code>default_validators = [validate_email_pie]
</code></pre>

<p>```</p>

<p><code>validate_email_pie</code> method makes GET request to Email Pie and gets back a response. The service checks for email format and mx records, it also catches misspellings (you can get it with <code>response['didyoumean']</code>). <code>validate_email_pie</code> raises <code>ValidationError</code> if the service detects an invalid email address. Now in your forms you can use <code>EmailPieField</code> like this:</p>

<p>``` python forms.py
from django import forms
from .fields import EmailPieField</p>

<p>class ContactForm(forms.Form):</p>

<pre><code>name = forms.CharField()
email = EmailPieField()
</code></pre>

<p>```</p>

<p>For those interested, here are some tests for the field :)</p>

<p>``` python tests.py
from django.test import TestCase
from django.core.exceptions import ValidationError
from .fields import EmailPieField</p>

<p>class EmailPieFieldTest(TestCase):</p>

<pre><code>def test_invalid_email(self):
    email_field = EmailPieField()
    self.assertRaises(ValidationError, email_field.clean, 'email@totest')

def test_invalid_mx(self):
    email_field = EmailPieField()
    self.assertRaises(ValidationError, email_field.clean, 'email@totest.com')

def test_valid_email(self):
    email_field = EmailPieField()
    self.assertEquals(email_field.clean('nam@namis.me'), 'nam@namis.me')
</code></pre>

<p>```
</span></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python class factory]]></title>
    <link href="http://blog.namis.me/2012/02/16/python-class-factory/"/>
    <updated>2012-02-16T12:05:00+11:00</updated>
    <id>http://blog.namis.me/2012/02/16/python-class-factory</id>
    <content type="html"><![CDATA[<p>Today's post will be on factory design pattern in Python. You can read more about it in <a href="http://en.wikipedia.org/wiki/Factory_method_pattern">Wiki</a>.
This design pattern allows you to create objects without specifying the exact class of object that will be created. Let's say, you want to create an object based on a provided string.</p>

<p>Here are some classes. Both of them are pets. We want to dynamically create a pet from one of those classes based on a string.</p>

<!-- more -->


<p>``` python
class Pony(object):</p>

<pre><code>def __init__(self, name):
    self.name = name
    self.hp = 100

def magic_power(self):
    # Attack opponent with super powers
    pass

def heal(self):
    # Increase hp (health point)
    pass
</code></pre>

<p>class Snake(object):</p>

<pre><code># Blah blah same as Pony
pass
</code></pre>

<p>```</p>

<p>Let's write a factory method to make this happen:</p>

<p>``` python
def create_class(pet_class_name):</p>

<pre><code># pet_class_name decides what class will be returned
if pet_class_name is 'pony':
    class InheritedClass(Pony):
        # You can add additional methods or attributes if needed
        pass
    return InheritedClass
elif pet_class_name is 'snake':
    # Or you can return the exact class
    return Snake
</code></pre>

<h1>Create MyPet from a string</h1>

<p>MyPet = create_class('pony')</p>

<h1>MyPet is now a subclass of Pony</h1>

<h1>It inherits everything from Pony</h1>

<p>django = MyPet('django')</p>

<h1>Kaboom !!!</h1>

<p>django.magic_power()
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python caching using defaultdict]]></title>
    <link href="http://blog.namis.me/2012/02/15/python-caching-using-defaultdict/"/>
    <updated>2012-02-15T10:46:00+11:00</updated>
    <id>http://blog.namis.me/2012/02/15/python-caching-using-defaultdict</id>
    <content type="html"><![CDATA[<p>Today, I've learnt about <code>defaultdict</code> container from my colleague, who uses it for caching. <code>defaultdict</code> container is part of <code>collections</code> module which provides high-performance container datatypes.
You can find more about it <a href="http://docs.python.org/library/collections.html#collections.defaultdict">here</a>. <strong>Note</strong>: New in version 2.5.</p>

<!-- more -->


<p>Let's see the code without caching mechanism:</p>

<p>``` python
import csv
from models import Pony, PonySwag</p>

<h1>Getting some data from csv file</h1>

<p>swags = csv.DictReader('pony_swag.csv', 'rU'), dialect='excel')</p>

<p>for swag in swags:</p>

<pre><code># Get or create a pony
pony = Pony.objects.get_or_create(
    name=swag['pony_name']
)[0]

# Create pony swag which belongs to a pony
PonySwag.objects.get_or_create(
    name=swag['swag_name'],
    power=swag['swag_power'],
    pony=pony 
)[0]
</code></pre>

<p>```</p>

<p>In this scenario, for every entry in csv, the code hits the database to get a pony (based on the name) to assign it to a corresponding swag. Now if we cache the created ponies, we would not have
to query the database anymore.</p>

<p>``` python
import csv
from collections import defaultdict
from models import Pony, PonySwag</p>

<p>class PoniesCache(defaultdict):</p>

<pre><code># If dict lookup fails this will be called
def __missing__(self, key):
    # Insert a pony in cache dict and return it
    pony = Pony.objects.get_or_create(name=key)[0]
    self[key] = pony
    return pony
</code></pre>

<p>ponies_cache = PoniesCache()</p>

<h1>Getting some data from csv file</h1>

<p>swags = csv.DictReader('pony_swag.csv', 'rU'), dialect='excel')</p>

<p>for swag in swags:</p>

<pre><code>pony = ponies_cache[swag['pony_name']]

# Create pony swag which belongs to a pony
PonySwag.objects.get_or_create(
    name=swag['swag_name'],
    power=swag['swag_power'],
    pony=pony 
)[0]
</code></pre>

<p>```</p>

<p>As you might have read, <code>defaultdict</code> is a subclass of <code>dict</code> and it overrides a method called <code>__missing__</code>.<br/>
<code>__missing__</code> is called by the <code>__getitem__()</code> method of the dict class when the requested key is not found (when <code>swag['pony_name']</code> value is not found in ponies_cache).
In our case, we override <code>__missing__</code> to create a pony and store it in cache (if it doesn't exist yet) and return it. This results in a pony being inserted in the dictionary with a key <code>swag['pony_name']</code>.</p>
]]></content>
  </entry>
  
</feed>
