<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | geeknam's blog]]></title>
  <link href="http://blog.namis.me/categories/python/atom.xml" rel="self"/>
  <link href="http://blog.namis.me/"/>
  <updated>2012-03-27T01:56:04+11:00</updated>
  <id>http://blog.namis.me/</id>
  <author>
    <name><![CDATA[Ngo Minh Nam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Django custom email form field for Email Pie]]></title>
    <link href="http://blog.namis.me/2012/03/27/django-custom-email-form-field-for-email-pie/"/>
    <updated>2012-03-27T01:14:00+11:00</updated>
    <id>http://blog.namis.me/2012/03/27/django-custom-email-form-field-for-email-pie</id>
    <content type="html"><![CDATA[<p><span class='pullquote-right' data-pullquote='Email Pie is a wonderful little JSON API that gives you a simple way to validate email addresses. We&#8217;ll let you know if that email address is legit or not.'>
As you know Django's <code>forms.EmailField()</code> is capable of validating email addresses but what if you wanted to validate the existence of a particular email address? I've found a pretty neat solution for that, it's called <a href="http://emailpie.com/">Email Pie</a>.
Email Pie is a wonderful little JSON API that gives you a simple way to validate email addresses. We'll let you know if that email address is legit or not.. You could either use the service hosted on emailpie.com or run your own instance (it's open source). In this post, I'm going to show you how to write a custom form field that makes use of Email Pie.</p>

<p>Make sure you pip install <code>requests</code> and <code>simplejson</code> before proceeding. Now create a <code>fields.py</code> file with the following content:</p>

<p>``` python fields.py
import requests
import simplejson</p>

<p>from django.core.exceptions import ValidationError</p>

<p>EMAIL_PIE_HOST = 'http://emailpie.com'  # change this if you run your own instance</p>

<p>def validate_email_pie(value):</p>

<pre><code>params = {'email': value}
response = requests.get('%s/v1/check' % EMAIL_PIE_HOST, params=params)
response = simplejson.loads(response.content)

if not response['success']:
    raise ValidationError(response['errors'][0]['message'])
</code></pre>

<p>class EmailPieField(forms.EmailField):</p>

<pre><code>default_validators = [validate_email_pie]
</code></pre>

<p>```</p>

<p><code>validate_email_pie</code> method makes GET request to Email Pie and gets back a response. The service checks for email format and mx records, it also catches misspellings (you can get it with <code>response['didyoumean']</code>). <code>validate_email_pie</code> raises <code>ValidationError</code> if the service detects an invalid email address. Now in your forms you can use <code>EmailPieField</code> like this:</p>

<p>``` python forms.py
from django import forms
from .fields import EmailPieField</p>

<p>class ContactForm(forms.Form):</p>

<pre><code>name = forms.CharField()
email = EmailPieField()
</code></pre>

<p>```</p>

<p>For those interested, here are some tests for the field :)</p>

<p>``` python tests.py
from django.test import TestCase
from django.core.exceptions import ValidationError
from .fields import EmailPieField</p>

<p>class EmailPieFieldTest(TestCase):</p>

<pre><code>def test_invalid_email(self):
    email_field = EmailPieField()
    self.assertRaises(ValidationError, email_field.clean, 'email@totest')

def test_invalid_mx(self):
    email_field = EmailPieField()
    self.assertRaises(ValidationError, email_field.clean, 'email@totest.com')

def test_valid_email(self):
    email_field = EmailPieField()
    self.assertEquals(email_field.clean('nam@namis.me'), 'nam@namis.me')
</code></pre>

<p>```
</span></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python class factory]]></title>
    <link href="http://blog.namis.me/2012/02/16/python-class-factory/"/>
    <updated>2012-02-16T12:05:00+11:00</updated>
    <id>http://blog.namis.me/2012/02/16/python-class-factory</id>
    <content type="html"><![CDATA[<p>Today's post will be on factory design pattern in Python. You can read more about it in <a href="http://en.wikipedia.org/wiki/Factory_method_pattern">Wiki</a>.
This design pattern allows you to create objects without specifying the exact class of object that will be created. Let's say, you want to create an object based on a provided string.</p>

<p>Here are some classes. Both of them are pets. We want to dynamically create a pet from one of those classes based on a string.</p>

<!-- more -->


<p>``` python
class Pony(object):</p>

<pre><code>def __init__(self, name):
    self.name = name
    self.hp = 100

def magic_power(self):
    # Attack opponent with super powers
    pass

def heal(self):
    # Increase hp (health point)
    pass
</code></pre>

<p>class Snake(object):</p>

<pre><code># Blah blah same as Pony
pass
</code></pre>

<p>```</p>

<p>Let's write a factory method to make this happen:</p>

<p>``` python
def create_class(pet_class_name):</p>

<pre><code># pet_class_name decides what class will be returned
if pet_class_name is 'pony':
    class InheritedClass(Pony):
        # You can add additional methods or attributes if needed
        pass
    return InheritedClass
elif pet_class_name is 'snake':
    # Or you can return the exact class
    return Snake
</code></pre>

<h1>Create MyPet from a string</h1>

<p>MyPet = create_class('pony')</p>

<h1>MyPet is now a subclass of Pony</h1>

<h1>It inherits everything from Pony</h1>

<p>django = MyPet('django')</p>

<h1>Kaboom !!!</h1>

<p>django.magic_power()
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python caching using defaultdict]]></title>
    <link href="http://blog.namis.me/2012/02/15/python-caching-using-defaultdict/"/>
    <updated>2012-02-15T10:46:00+11:00</updated>
    <id>http://blog.namis.me/2012/02/15/python-caching-using-defaultdict</id>
    <content type="html"><![CDATA[<p>Today, I've learnt about <code>defaultdict</code> container from my colleague, who uses it for caching. <code>defaultdict</code> container is part of <code>collections</code> module which provides high-performance container datatypes.
You can find more about it <a href="http://docs.python.org/library/collections.html#collections.defaultdict">here</a>. <strong>Note</strong>: New in version 2.5.</p>

<!-- more -->


<p>Let's see the code without caching mechanism:</p>

<p>``` python
import csv
from models import Pony, PonySwag</p>

<h1>Getting some data from csv file</h1>

<p>swags = csv.DictReader('pony_swag.csv', 'rU'), dialect='excel')</p>

<p>for swag in swags:</p>

<pre><code># Get or create a pony
pony = Pony.objects.get_or_create(
    name=swag['pony_name']
)[0]

# Create pony swag which belongs to a pony
PonySwag.objects.get_or_create(
    name=swag['swag_name'],
    power=swag['swag_power'],
    pony=pony 
)[0]
</code></pre>

<p>```</p>

<p>In this scenario, for every entry in csv, the code hits the database to get a pony (based on the name) to assign it to a corresponding swag. Now if we cache the created ponies, we would not have
to query the database anymore.</p>

<p>``` python
import csv
from collections import defaultdict
from models import Pony, PonySwag</p>

<p>class PoniesCache(defaultdict):</p>

<pre><code># If dict lookup fails this will be called
def __missing__(self, key):
    # Insert a pony in cache dict and return it
    pony = Pony.objects.get_or_create(name=key)[0]
    self[key] = pony
    return pony
</code></pre>

<p>ponies_cache = PoniesCache()</p>

<h1>Getting some data from csv file</h1>

<p>swags = csv.DictReader('pony_swag.csv', 'rU'), dialect='excel')</p>

<p>for swag in swags:</p>

<pre><code>pony = ponies_cache[swag['pony_name']]

# Create pony swag which belongs to a pony
PonySwag.objects.get_or_create(
    name=swag['swag_name'],
    power=swag['swag_power'],
    pony=pony 
)[0]
</code></pre>

<p>```</p>

<p>As you might have read, <code>defaultdict</code> is a subclass of <code>dict</code> and it overrides a method called <code>__missing__</code>.<br/>
<code>__missing__</code> is called by the <code>__getitem__()</code> method of the dict class when the requested key is not found (when <code>swag['pony_name']</code> value is not found in ponies_cache).
In our case, we override <code>__missing__</code> to create a pony and store it in cache (if it doesn't exist yet) and return it. This results in a pony being inserted in the dictionary with a key <code>swag['pony_name']</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python strptime is not thread-safe]]></title>
    <link href="http://blog.namis.me/2012/02/14/python-strptime-is-not-thread-safe/"/>
    <updated>2012-02-14T15:30:00+11:00</updated>
    <id>http://blog.namis.me/2012/02/14/python-strptime-is-not-thread-safe</id>
    <content type="html"><![CDATA[<p>When using Python to automate your work, threading is one thing you need to know of. I've got into a problem with threading when parsing time. To be exact: <code>datetime.datetime.strptime()</code> function was not thread-safe. Luckily, I found a solution on <a href="http://stackoverflow.com/questions/4625149/fixed-strptime-exception-with-thread-lock-but-slows-down-the-program">StackOverflow</a>.</p>

<!-- more -->


<p>This is how the problem occurred:</p>

<p>``` python
from datetime import datetime
import threading</p>

<p>def parse_time(value):</p>

<pre><code># Parse time with strptime()
datetime.strptime(value], "%Y-%m-%d %H:%M:%S.%f")
</code></pre>

<p>t = threading.Thread(target=parse_time, args=(value))
t.start()
```
Fixing it was pretty straightforward. Just make a dummy call on strptime() before creating a thread:</p>

<p><code>python
datetime.strptime("2011-04-05 18:40:58.525996", "%Y-%m-%d %H:%M:%S.%f")
t = threading.Thread(target=format_time, args=(some_values))
t.start()
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Regenerating Google's ClientLogin AuthToken in Django]]></title>
    <link href="http://blog.namis.me/2012/02/14/regenerating-googles-clientlogin-authtoken-in-django/"/>
    <updated>2012-02-14T12:47:00+11:00</updated>
    <id>http://blog.namis.me/2012/02/14/regenerating-googles-clientlogin-authtoken-in-django</id>
    <content type="html"><![CDATA[<p>If your application makes use of Google API, you will most likely have to deal with AuthToken expiry (unless you use oAuth). As far as I know, AuthToken generated with ClientLogin authorization expires after 2 weeks. Therefore, it's good to have a solution to auto regenerate it. First of all, create a model that stores the token and the last updated day.</p>

<!-- more -->


<p>``` python
from django.db import models
from datetime import datetime, timedelta</p>

<p>class AuthToken(models.Model):</p>

<pre><code>token = models.TextField()
last_updated = models.DateTimeField(auto_now_add=True)

def token_update(self):
    # Check if the token's lifespan is more than n days (n=1 in this case)
    # You can adjust n value to whatever you want

    if datetime.now() - self.last_updated &gt; timedelta(days=1):
        return True
    return False
</code></pre>

<p>```</p>

<p>Now let's write a function that regenerates AuthToken and saves it back to database.</p>

<p>```python
from models import AuthToken</p>

<p>CLIENT_LOGIN_URL = 'https://www.google.com/accounts/ClientLogin'</p>

<p>def regenerate_authtoken():</p>

<pre><code>auth_token = AuthToken.objects.all()[0]
if auth_token.token_update():
    data = urllib.urlencode(
        {
            'Email': 'youremail@gmail.com',
            'Passwd': 'yourpassword',
            'service': 'service_name',
            'accountType': 'GOOGLE'
        }
    )
    req = urllib2.Request(CLIENT_LOGIN_URL, data=data)
    resp = urllib2.urlopen(req)
    resp_body = resp.read()

    resp_dict = dict(
        x.split('=') for x in resp_body.split('\n') if x
    )
    auth_token.token = resp_dict['Auth']
    auth_token.save()
</code></pre>

<p>```</p>

<p>With this approach you would have to call <code>regenerate_authtoken()</code> every time you make API requests. Let me know if you have a better solution.</p>
]]></content>
  </entry>
  
</feed>
