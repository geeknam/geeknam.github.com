<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: django | geeknam's blog]]></title>
  <link href="http://blog.namis.me/categories/django/atom.xml" rel="self"/>
  <link href="http://blog.namis.me/"/>
  <updated>2012-04-21T17:20:17+10:00</updated>
  <id>http://blog.namis.me/</id>
  <author>
    <name><![CDATA[Ngo Minh Nam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Burn your fixtures, use model factories]]></title>
    <link href="http://blog.namis.me/2012/04/21/burn-your-fixtures/"/>
    <updated>2012-04-21T16:46:00+10:00</updated>
    <id>http://blog.namis.me/2012/04/21/burn-your-fixtures</id>
    <content type="html"><![CDATA[<p>This blog post is inspired by one of the talks in PyCon US 2012 by <a href="http://twitter.com/carljm">Carl Meyer</a> named <a href="http://pyvideo.org/video/699/testing-and-django">Testing and Django</a> in which he discusssed the guidelines for writing good tests.</p>

<p>After watching the whole talk, I realised what I've been doing is all wrong. The fact that tests I write run within minutes shows how terrible my unit-test-fu is. Using fixtures was a really bad idea. Each test case I wrote would load some fixtures to setup necessary dependencies. Sometimes, this creates a problem when the model has been redesigned. The fixtures would have to be edited due to the change of the model otherwise they won't be installed properly.</p>

<p>Instead of using fixtures, Carl introduced <code>model factories</code> which would create a model instance with default values. Of course, you will have a flexibility to change those default values to suit each of your test because naturally, when you test a behaviour of a class, you definitely need it to be in different conditions.</p>

<!-- more -->


<p>Here is an example of a model factory that was used in the talk:</p>

<p>``` python
def create_profile(**kwargs):</p>

<pre><code>defaults = {
    "likes_cheese": True,
    "age": 32,
    "address": "3815 Brookside Dr",
}
defaults.update(kwargs)
if "user" not in defaults:
    defaults["user"] = create_user()
return Profile.objects.create(**defaults)
</code></pre>

<p>```</p>

<p>And this is how you could use it in the test:</p>

<p>``` python
def test_can_vote(self):</p>

<pre><code>"""A user age 18+ can vote in the US."""
profile = create_profile(age=18)
self.assertTrue(profile.can_vote)
</code></pre>

<p>```</p>

<p>This approach solves the problem with maintaining the fixtures to suit your model design. If your model changes, the only thing you have to edit is the default values of the factory. Therefore <code>model factories</code> are way easier to maintain. If you need a large data set, you could easily write a for loop that wraps the model factory. So burn all your fixture right now !!!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django custom email form field for Email Pie]]></title>
    <link href="http://blog.namis.me/2012/03/27/django-custom-email-form-field-for-email-pie/"/>
    <updated>2012-03-27T01:14:00+11:00</updated>
    <id>http://blog.namis.me/2012/03/27/django-custom-email-form-field-for-email-pie</id>
    <content type="html"><![CDATA[<p><span class='pullquote-right' data-pullquote='Email Pie is a wonderful little JSON API that gives you a simple way to validate email addresses. We&#8217;ll let you know if that email address is legit or not.'>
As you know Django's <code>forms.EmailField()</code> is capable of validating email addresses but what if you wanted to validate the existence of a particular email address? I've found a pretty neat solution for that, it's called <a href="http://emailpie.com/">Email Pie</a>.
Email Pie is a wonderful little JSON API that gives you a simple way to validate email addresses. We'll let you know if that email address is legit or not.. You could either use the service hosted on emailpie.com or run your own instance (it's open source). In this post, I'm going to show you how to write a custom form field that makes use of Email Pie.</p>

<!-- more -->


<p>Make sure you pip install <code>requests</code> and <code>simplejson</code> before proceeding. Now create a <code>fields.py</code> file with the following content:</p>

<p>``` python fields.py
import requests
import simplejson</p>

<p>from django import forms
from django.core.exceptions import ValidationError</p>

<p>EMAIL_PIE_HOST = 'http://emailpie.com'  # change this if you run your own instance</p>

<p>def validate_email_pie(value):</p>

<pre><code>params = {'email': value}
response = requests.get('%s/v1/check' % EMAIL_PIE_HOST, params=params)
response = simplejson.loads(response.content)

if not response['success']:
    raise ValidationError(response['errors'][0]['message'])
</code></pre>

<p>class EmailPieField(forms.EmailField):</p>

<pre><code>default_validators = [validate_email_pie]
</code></pre>

<p>```</p>

<p><code>validate_email_pie</code> method makes GET request to Email Pie and gets back a response. The service checks for email format and mx records, it also catches misspellings (you can get it with <code>response['didyoumean']</code>). <code>validate_email_pie</code> raises <code>ValidationError</code> if the service detects an invalid email address. Now in your forms you can use <code>EmailPieField</code> like this:</p>

<p>``` python forms.py
from django import forms
from .fields import EmailPieField</p>

<p>class ContactForm(forms.Form):</p>

<pre><code>name = forms.CharField()
email = EmailPieField()
</code></pre>

<p>```</p>

<p>For those interested, here are some tests for the field :)</p>

<p>``` python tests.py
from django.test import TestCase
from django.core.exceptions import ValidationError
from .fields import EmailPieField</p>

<p>class EmailPieFieldTest(TestCase):</p>

<pre><code>def test_invalid_email(self):
    email_field = EmailPieField()
    self.assertRaises(ValidationError, email_field.clean, 'email@totest')

def test_invalid_mx(self):
    email_field = EmailPieField()
    self.assertRaises(ValidationError, email_field.clean, 'email@totest.com')

def test_valid_email(self):
    email_field = EmailPieField()
    self.assertEquals(email_field.clean('nam@namis.me'), 'nam@namis.me')
</code></pre>

<p>```
</span></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python caching using defaultdict]]></title>
    <link href="http://blog.namis.me/2012/02/15/python-caching-using-defaultdict/"/>
    <updated>2012-02-15T10:46:00+11:00</updated>
    <id>http://blog.namis.me/2012/02/15/python-caching-using-defaultdict</id>
    <content type="html"><![CDATA[<p>Today, I've learnt about <code>defaultdict</code> container from my colleague, who uses it for caching. <code>defaultdict</code> container is part of <code>collections</code> module which provides high-performance container datatypes.
You can find more about it <a href="http://docs.python.org/library/collections.html#collections.defaultdict">here</a>. <strong>Note</strong>: New in version 2.5.</p>

<!-- more -->


<p>Let's see the code without caching mechanism:</p>

<p>``` python
import csv
from models import Pony, PonySwag</p>

<h1>Getting some data from csv file</h1>

<p>swags = csv.DictReader('pony_swag.csv', 'rU'), dialect='excel')</p>

<p>for swag in swags:</p>

<pre><code># Get or create a pony
pony = Pony.objects.get_or_create(
    name=swag['pony_name']
)[0]

# Create pony swag which belongs to a pony
PonySwag.objects.get_or_create(
    name=swag['swag_name'],
    power=swag['swag_power'],
    pony=pony 
)[0]
</code></pre>

<p>```</p>

<p>In this scenario, for every entry in csv, the code hits the database to get a pony (based on the name) to assign it to a corresponding swag. Now if we cache the created ponies, we would not have
to query the database anymore.</p>

<p>``` python
import csv
from collections import defaultdict
from models import Pony, PonySwag</p>

<p>class PoniesCache(defaultdict):</p>

<pre><code># If dict lookup fails this will be called
def __missing__(self, key):
    # Insert a pony in cache dict and return it
    pony = Pony.objects.get_or_create(name=key)[0]
    self[key] = pony
    return pony
</code></pre>

<p>ponies_cache = PoniesCache()</p>

<h1>Getting some data from csv file</h1>

<p>swags = csv.DictReader('pony_swag.csv', 'rU'), dialect='excel')</p>

<p>for swag in swags:</p>

<pre><code>pony = ponies_cache[swag['pony_name']]

# Create pony swag which belongs to a pony
PonySwag.objects.get_or_create(
    name=swag['swag_name'],
    power=swag['swag_power'],
    pony=pony 
)[0]
</code></pre>

<p>```</p>

<p>As you might have read, <code>defaultdict</code> is a subclass of <code>dict</code> and it overrides a method called <code>__missing__</code>.<br/>
<code>__missing__</code> is called by the <code>__getitem__()</code> method of the dict class when the requested key is not found (when <code>swag['pony_name']</code> value is not found in ponies_cache).
In our case, we override <code>__missing__</code> to create a pony and store it in cache (if it doesn't exist yet) and return it. This results in a pony being inserted in the dictionary with a key <code>swag['pony_name']</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Regenerating Google's ClientLogin AuthToken in Django]]></title>
    <link href="http://blog.namis.me/2012/02/14/regenerating-googles-clientlogin-authtoken-in-django/"/>
    <updated>2012-02-14T12:47:00+11:00</updated>
    <id>http://blog.namis.me/2012/02/14/regenerating-googles-clientlogin-authtoken-in-django</id>
    <content type="html"><![CDATA[<p>If your application makes use of Google API, you will most likely have to deal with AuthToken expiry (unless you use oAuth). As far as I know, AuthToken generated with ClientLogin authorization expires after 2 weeks. Therefore, it's good to have a solution to auto regenerate it. First of all, create a model that stores the token and the last updated day.</p>

<!-- more -->


<p>``` python
from django.db import models
from datetime import datetime, timedelta</p>

<p>class AuthToken(models.Model):</p>

<pre><code>token = models.TextField()
last_updated = models.DateTimeField(auto_now_add=True)

def token_update(self):
    # Check if the token's lifespan is more than n days (n=1 in this case)
    # You can adjust n value to whatever you want

    if datetime.now() - self.last_updated &gt; timedelta(days=1):
        return True
    return False
</code></pre>

<p>```</p>

<p>Now let's write a function that regenerates AuthToken and saves it back to database.</p>

<p>```python
from models import AuthToken</p>

<p>CLIENT_LOGIN_URL = 'https://www.google.com/accounts/ClientLogin'</p>

<p>def regenerate_authtoken():</p>

<pre><code>auth_token = AuthToken.objects.all()[0]
if auth_token.token_update():
    data = urllib.urlencode(
        {
            'Email': 'youremail@gmail.com',
            'Passwd': 'yourpassword',
            'service': 'service_name',
            'accountType': 'GOOGLE'
        }
    )
    req = urllib2.Request(CLIENT_LOGIN_URL, data=data)
    resp = urllib2.urlopen(req)
    resp_body = resp.read()

    resp_dict = dict(
        x.split('=') for x in resp_body.split('\n') if x
    )
    auth_token.token = resp_dict['Auth']
    auth_token.save()
</code></pre>

<p>```</p>

<p>With this approach you would have to call <code>regenerate_authtoken()</code> every time you make API requests. Let me know if you have a better solution.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[More on Django FormView]]></title>
    <link href="http://blog.namis.me/2012/02/13/more-on-django-formview/"/>
    <updated>2012-02-13T21:49:00+11:00</updated>
    <id>http://blog.namis.me/2012/02/13/more-on-django-formview</id>
    <content type="html"><![CDATA[<p><span class='pullquote-right' data-pullquote='Django’s generic views were developed to take away the monotony of repeating certain patterns again and again'>
I've been trying to limit myself to use class based generic views as much as possible. Django’s generic views were developed to take away the monotony of repeating certain patterns again and again. Some generics views are properly documented (like ListView and DetailView), however I wanted to make use of FormView to process my forms. Unfortunately, there were no FormView examples provided. So here it is.</p>

<!-- more -->


<p>``` python
from django.views import generic</p>

<p>class EmailPreferenceView(generic.FormView):</p>

<pre><code>form_class = EmailPreferenceForm

def get(self, *args, **kwargs):
    # You can access url variables from kwargs
    # url: /email_preferences/geeknam &gt; kwargs['username'] = 'geeknam'
    # Assign to self.subscriber to be used later
    self.subscriber = get_subscriber(kwargs['username'])

def post(self, request, *args, **kwargs):
    # Process view when the form gets POSTed
    pass

def get_initial(self):
    # Populate ticks in BooleanFields
    initial = {}
    for s in self.subscriber.events.all():
        initial[s.value_id] = True
    return initial

def get_form(self, form_class):
    # Initialize the form with initial values and the subscriber object
    # to be used in EmailPreferenceForm for populating fields
    return form_class(
        initial=self.get_initial(),
        subscriber=self.subscriber
    )

def get_success_url(self):
    # Redirect to previous url
    return self.request.META.get('HTTP_REFERER', None)

def form_valid(self, form):
    messages.info(
        self.request,
        "You have successfully changed your email notifications"
    )
    return super(EmailPreferenceView, self).form_valid(form)

def form_invalid(self, form):
    messages.info(
        self.request,
        "Your submission has not been saved. Try again."
    )
    return super(EmailPreferenceView, self).form_invalid(form)
</code></pre>

<p>email_preferences = EmailPreferenceView.as_view()
```
</span></p>
]]></content>
  </entry>
  
</feed>
